/**
 *  Copyright 2016 IBM Corp. All Rights Reserved
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.  
 */

var loggerWrapper = require('./util/security-logger'),
CommonCache = require('./util/common-cache'),
tokenValidator = require("./util/mfp-token-validator"),
FilterUtil = require('./util/filter-util'),
Constant = require('./constant'),
Analytics = require('./analytics-sdk-node/analytics-sdk-node.js'),
_ = require('underscore'),
passport = require('passport-strategy'), 
util = require('util'),
fs = require('fs');

function Strategy(options) {
    
    this.authServerUrl = options && options.authServerUrl;
    this.confClientID = options && options.confClientID;
    this.confClientPass = options && options.confClientPass;

    passport.Strategy.call(this);
    
    if (options && options.name) {
        this.name = options.name;
    } else {
        // Default name
        this.name = Constant.MFP_STRATEGY_DEFAULT;
    }
    
    this._verify = tokenValidator.validate;
    this.options = options;
    
    this.cacheSize = 50000;
    if ( (options) && (options.cacheSize !== undefined) && (options.cacheSize >= 0) ) {
        this.cacheSize = options.cacheSize;
    }
    this.securityContextCache = new CommonCache(this.cacheSize);
    this.confClientTokenCache = new CommonCache(1);

    if (options && options.logger) {
        loggerWrapper.setLogger(options.logger);
    }
    
    this.serverIpAddress;
    var that = this;
    require('dns').lookup(require('os').hostname(), function (err, address, family) {
        if (!err) {
            that.serverIpAddress = address;
        }
    });
    if (options && options.certificate) {
        fs.readFile(options.certificate, 'UTF-8', function(err,data) {
            if (err) {
                loggerWrapper.getLogger().error('Failed to read the certificate file.');
            } else {
                that.certificate = data;
            }
        });
    }

    if (options && options.analytics && options.analytics.onpremise) {
        var config = {
            "url" : options.analytics.onpremise.url,
            "username" : options.analytics.onpremise.username,
            "password" : options.analytics.onpremise.password
        };
        this.analytics = Analytics(Constant.ANALYTICS_EVENT_TYPE, function errorHandler (err) {
            loggerWrapper.getLogger().error('Initialize the analytics instance failed.' , err);
        }, {onpremise : config});
    } else {
        this.analytics = Analytics(Constant.ANALYTICS_EVENT_TYPE, function errorHandler (err) {
            loggerWrapper.getLogger().error('Initialize the analytics instance failed.' , err);
        });
    }

    return this;
}

/**
 * Inherit from `passport.Strategy`.
 */
util.inherits(Strategy, passport.Strategy);

Strategy.prototype.authenticate = function(req,options) {
    var strategy = this;
    
    if (!strategy.authServerUrl) {
        var msg = 'The option "authServerUrl" is required.';
        loggerWrapper.getLogger().error(msg);
        return this.fail(500);
    }
    
    if (!options) {
        options = {};
    }

    var authenticateOptions = FilterUtil.clone(options);
    
    authenticateOptions.authServerUrl = strategy.authServerUrl;
    authenticateOptions.confClientID = strategy.confClientID;
    authenticateOptions.confClientPass = strategy.confClientPass;

    var authorization;
    if (req.headers && req.headers.authorization) {
        authorization = req.headers.authorization;
    }
    
    authenticateOptions.authorization = authorization;
    
    var startTime = process.hrtime();
    
    
    function sendFailureEvent(info) {
        var serverProcessingTime = getServerProcessingTime(startTime);
        info = info || {code:Constant.AUTHORIZATION_FAILED_INVALID_TOKEN, status:401, validationCode:'AUTHORIZATION_FAILED'};
        
        if (req['headers']['x-mfp-analytics-metadata']) {
            analyticsMetadata = JSON.parse(req['headers']['x-mfp-analytics-metadata']);
            var event = {
                appID: analyticsMetadata.appStoreId,
                appName: analyticsMetadata.appStoreLabel,
                appVersion: analyticsMetadata.appVersionDisplay,
                appVersionCode: analyticsMetadata.appVersionCode,
                authSuccess: false,
                deviceBrand: analyticsMetadata.brand,
                deviceID: analyticsMetadata.deviceID,
                deviceModel: analyticsMetadata.model,                    
                deviceOS: analyticsMetadata.os,
                deviceOSversion: analyticsMetadata.osVersion,
                resourceURL: req && (req.protocol + Constant.COLON + Constant.DOUBLEFWDSLASH + req.headers[Constant.HOST] + req.originalUrl),
                requestMethod: req.method,
                serverProcessingTime: serverProcessingTime,
                trackingID: req['headers']['x-wl-analytics-tracking-id'],                    
                userAgent: req.headers['user-agent'],
                validationCode: info.validationCode      
            };
            
            if ((info.status == 401) && (info.code == Constant.AUTHORIZATION_FAILED_INSUFFICIENT_SCOPE)) {
                // The response code should be 403 and not 401, because passport module will add WWW-Authenticate header only if the status is 401.
                // mfp-passport considerates the info.code in order to decide the response's http status code.
                event.responseCode = 403;
            } else {
                event.responseCode = info.status;
            }
            
            if (strategy.serverIpAddress) {
                event.serverIpAddress = strategy.serverIpAddress;
            }
            sendReport(strategy, event);
        }
    }
    
    function sendSuccessEvent(securityContext) {
        var serverProcessingTime = getServerProcessingTime(startTime);
        var event = {
            appID: securityContext && securityContext[Constant.MFP_APPLICATION] && securityContext[Constant.MFP_APPLICATION].id,
            appVersion: securityContext && securityContext[Constant.MFP_APPLICATION] && securityContext[Constant.MFP_APPLICATION].version,
            authSuccess: true,
            deviceID : securityContext && securityContext[Constant.MFP_DEVICE] && securityContext[Constant.MFP_DEVICE].id,
            deviceModel : securityContext && securityContext[Constant.MFP_DEVICE] && securityContext[Constant.MFP_DEVICE].hardware,
            resourceURL: req && (req.protocol + Constant.COLON + Constant.DOUBLEFWDSLASH + req.headers[Constant.HOST] + req.originalUrl),
            responseCode: 200,
            requestMethod: req.method,
            serverProcessingTime: serverProcessingTime,
            trackingID: req['headers']['x-wl-analytics-tracking-id'],
            userAgent: req.headers['user-agent'],
            validationCode: 'AUTHORIZATION_SUCCESS'
        };
        if (strategy.serverIpAddress) {
            event.serverIpAddress = strategy.serverIpAddress;
        }
        if (req['headers']['x-mfp-analytics-metadata']) {
            analyticsMetadata = JSON.parse(req['headers']['x-mfp-analytics-metadata']);
            event.appName = analyticsMetadata.appStoreLabel;
            event.appVersionCode = analyticsMetadata.appVersionCode;
            event.deviceBrand = analyticsMetadata.brand;
            event.deviceOS = analyticsMetadata.os;
            event.deviceOSversion = analyticsMetadata.osVersion;
        }
        sendReport(strategy, event);
    }
    
    // Verifies whether the authentication succeeded.
    function verified(err, securityContext, info) {
        var event, analyticsMetadata;
        if (!securityContext) {
            if (strategy.analytics) {
                sendFailureEvent(info);            
            }
            return strategy.fail(getChallenge(info.code,info.scope),info.status);
        }
        
        if (strategy.analytics) {
            //the securityContext has value, represents validation successfully. Otherwise, failed.
            sendSuccessEvent(securityContext);
        }

        if (err) {
            return strategy.error(err); 
        }
        req.securityContext = securityContext;
        var user = securityContext[Constant.USERNAME];
        strategy.success(user, null);
    }

    strategy._verify(authenticateOptions,verified);
};

function getServerProcessingTime(startTime) {
    var diff = process.hrtime(startTime);
    var ms = diff[0] * 1e3 + diff[1] * 1e-6;
    return ms; 
}

function sendReport(strategy, event) {
    try {
        strategy.analytics.reportEvent(Constant.ANALYTICS_EVENT_TYPE,event);
    } catch(error) {
        loggerWrapper.getLogger().error('Sending analytics event error',event,error);
    }    
}

// Gets the challenge for WWW-Authenticate header.
function getChallenge(errCode,scope) {
    if (errCode == Constant.AUTHORIZATION_FAILED_MFP_SERVER_CONFLICT_RESPONSE) {
        // No WWW-Authenticate header is going to be added.
        return "";
    }
    var challenge = Constant.AUTHORIZATION_BEARER;
    if (errCode) {
        if (errCode == Constant.AUTHORIZATION_FAILED_MISSING_AUTHORIZATION) {
            return challenge;
        }
        challenge += ' error="' + errCode + '"';
        
        if (errCode == Constant.AUTHORIZATION_FAILED_INVALID_TOKEN) {
            return challenge;
        }
    }
    if (scope) {
        challenge += ', scope="' + scope + '"';
    }
    
    return challenge;
};

exports = module.exports = Strategy;