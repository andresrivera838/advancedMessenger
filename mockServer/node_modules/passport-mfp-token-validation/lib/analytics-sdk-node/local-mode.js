
/**
 * @license
 * Licensed Materials - Property of IBM
 * 5725-I43 (C) Copyright IBM Corp. 2006, 2013. All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */
/*global exports, require, console*/
// Performs setup for running in local mode, and returns an environment object
// for tasks specific to local mode.
//
// Every incoming request is logged to the console.  Most responses are logged
// too.
//
// This is in its own module so it doesn't add overhead when we're running in
// BlueMix.  It requires the express and body-parser modules.
exports.setupLocalMode = function setupLocalMode(emitter, http, express, bodyParser) {

    'use strict';

    var CONSTANTS = require('./constants');

    // Run with a local server and use HTTP.
    // Create a server listening on a port that's not already in use.
    var app = express(),
        server = http.createServer(app),
        port = 0;

    // Add middleware for parsing the JSON body of usage data events.
    app.use(bodyParser.json());

    // Add middleware that logs every incoming request.
    app.use(function(request, response, next) {
        console.log('{"request": "%s"}', request.path);
        next();
    });

    var eventRouteHandler = function(request, response) {
        // Collect the data and parse each line into an object.
        var payload = '';
        request.on('data', function(chunk) {
            payload += chunk;
        });
        request.on('end',
            function() {
                var body = payload.split('\n');
                if (body[body.length - 1].trim().length === 0) {
                    // If there's an empty string at the end, remove it.
                    body.pop();
                }
                if (body.length === 1) {
                    body = JSON.parse(body[0]);
                } else {
                    body = body.map(JSON.parse);
                }
                if (request.query.bulk || request.params.typeName === '_bulk' || request.path.indexOf('_bulk') !== -1) {
                    // More than one event may have been sent.
                    var events = {
                        bulk: true,
                        body: body
                    };
                    console.log(JSON.stringify(events));
                } else {
                    // One event was sent.
                    var event = {
                        bulk: false,
                        body: body
                    };
                    console.log(JSON.stringify(event));
                }

                response.status(200).send({});
            });
    };

    // Pretend to be Elastic Search, listening for events.
    app.post('/FakeElasticSearch/v1/events/:typeName', eventRouteHandler);

    // Pretend to be Elastic Search, listening for events.
    app.post('/FakeElasticSearch/v1/events/:typeName/_bulk', eventRouteHandler);

    // Pretend to be the Usage Data Gateway, listening for billing data.
    app.post('/v1/metering/services/:srvInstId/usage',
        function(request, response) {
            console.log(JSON.stringify(request.body));
            response.location('https://fake-udg/' + request.params.srvInstId + '/1');
            response.status(201).send({});
        });

    // Pretend to be the service broker, providing info on which services
    // are used by an app.  If the appID is FORCE_AN_ERROR_PLEASE_PLEASE then
    // the response will be a 500 error.  If the appID starts with INVALID_APP_ID
    // then the response will be an empty array.
    app.get('/v2/apps/:appID',
        function(request, response) {
            if (request.params.appID === 'FORCE_AN_ERROR_PLEASE_PLEASE') {
                response.status(500).send('You wanted an error.');
            } else if (/^INVALID_APP_ID/.test(request.params.appID)) {
                response.status(200).send([]);
            } else {
                response.status(200).send([{
                    service_id: 'Data_Dev-20140408MBaaS',
                    organization_guid: 'Taco_Org',
                    space_guid: 'dev',
                    instance_id: 'data-service-instance-55',
                    service_name: 'Data_Dev',
                    app_guid: request.params.appID,
                    status: 'ENABLED'
                }, {
                    service_id: 'MAS-20140408MBaaS',
                    organization_guid: 'Org #2',
                    space_guid: 'dev',
                    instance_id: 'mas-service-instance-66',
                    service_name: 'MAS',
                    app_guid: request.params.appID,
                    status: 'ENABLED'
                }, {
                    service_id: 'Push-20140408MBaaS',
                    organization_guid: 'Org #2',
                    space_guid: 'svt',
                    instance_id: 'push-service-instance-77',
                    service_name: 'Push',
                    app_guid: request.params.appID,
                    status: 'ENABLED'
                }]);
            }
        });

    server.on('listening', function serverReady() {
        port = server.address().port;
        emitter.emit('ready');
    });

    server.on('error', function(e) {
        emitter.emit('error', e);
    });

    emitter.startServer = function startServer() {
        server.listen();
    };
    emitter.stopServer = function stopServer() {
        server.close();
    };

    function loadValidator() {
        var validator = {};
        validator.getMappings = function() {
            return {
                Bob: ['timestamp', 'a', 'b'],
                ObjectCreate: ['timestamp', 'appID', 'database', 'object'],
                FileTotal: ['timestamp', 'appID', 'size', 'fileCount'],
                FileQuery: ['timestamp', 'appID', 'collection', 'file'],
                FruitEvent: ['timestamp', 'fruit', 'amount'],
                SaladEvent: ['timestamp', 'variety', 'amount'],
                InjuryEvent: ['timestamp', 'location', 'damage'],
                SportingEvent: ['timestamp', 'sport', 'leader', 'players'],
                Lou: ['timestamp', 'aa'],
                Blah: ['timestamp', 'aaa', 'bbb']
            };
        };

        validator.isValid = function(eventType, event, emitter) {
            // check the event type
            var actualProps = validator.getMappings()[eventType];
            if (typeof actualProps === 'undefined') {
                emitter.emit('error', eventType + ' is not a known event type.');
                return false;
            }

            var eventProps = Object.keys(event);

            if (eventProps.length > actualProps.length) {
                emitter.emit('error', 'An event has more properties than its type, ' + eventType +
                '. Event properties: [' + eventProps + ']. ' + eventType + ' properties: [' + actualProps + '].');
                return false;
            }

            var valid = true;

            // check the keys of the event
            eventProps.forEach(function(key) {
                if (actualProps.indexOf(key) < 0) {
                    emitter.emit('error', 'An event has property "' + key + '" which is not in its type, ' + eventType +
                    '. Event properties: [' + eventProps + ']. ' + eventType + ' properties: [' + actualProps + '].');
                    valid = false;
                    return;
                }
            });

            return valid;
        };

        return validator;
    }

    function localElasticSearchOptions(method, path) {

        return {
            method: method,
            path: '/FakeElasticSearch/v1/events' + path,
            hostname: 'localhost',
            port: port
        };
    }

    function localOptions(method, path) {
        return {
            method: method,
            path: path,
            hostname: 'localhost',
            port: port
        };
    }

    return {
        billingInterval: 5000, // 5 seconds
        name: CONSTANTS.localMode,
        billingOptions: localOptions,
        loadValidator: loadValidator,
        get: http.get,
        elasticsearchOptions: localElasticSearchOptions,
        serviceBrokerOptions: localOptions,
        request: http.request
    };

};