
/**
 * @license
 * Licensed Materials - Property of IBM
 * 5725-I43 (C) Copyright IBM Corp. 2006, 2013. All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */
/*global module*/
// Starts a timer to process events being reported via the SDK.  Events are buffered and a timer periodically sends
// the events (in bulk) to the Analytics Repository.  The buffer must be placed in the "ready" state before events
// will be sent.  "ready" state is set once the event types have been loaded from the Analytics Repo.  The properties
// of reported events are validated before sending them to repo.
function _createEventBuffer(logger, utils, reportEventDelay, emitter, environment, eventValidator, setIntervalFunction) {

    'use strict';

    logger.logEnter('createEventBuffer');

    // Each element of the buffer is an array containing an event type's
    // name, followed by events of that type.  The buffer's typeMap field
    // has a property for each event type's name, whose value is the index
    // where events of that type are stored.
    //
    // A buffer with two events of type A and one event of type B would look
    // like this:
    //
    //    buffer[0] = ['A', {event-object-1}, {event-object-2}]
    //    buffer[1] = ['B', {event-object-3}]
    //    buffer.typeMap.A = 0;
    //    buffer.typeMap.B = 1;
    var buffer = [],
        eventCount = 0,
        canDelaySend = true;

    buffer.typeMap = {};

    // This function will run every so often to send the buffered events to Elastic Search.
    function sendEvents() {
        // console.log('ZAC in send');

        logger.logEnter('sendEvents with eventCount ' + eventCount);

        if (eventCount > 0) {

            // If there are fewer than 10 events, we wait for more to arrive
            // before sending them.  Only delay sending them once so they
            // don't get too old.
            if (eventCount < 10 && canDelaySend) {

                // Wait for more events.
                canDelaySend = false;

                logger.logExit('sendEvents, wait for more events');
                return;
            }

            // Post the events.
            canDelaySend = true;

            if (eventCount === 0) {
                // All events were invalid.  We're done.
                logger.logExit('sendEvents, all events were invalid');
                return;
            }

            try {
                // Use one of the three APIs: there's one for a single
                // event, one for multiple events of the same type, and
                // one for a mix of types.
                var path,
                    request,
                    events,
                    eventData;

                if (buffer.length === 1) {
                    // They're all the same type.
                    eventData = buffer[0];

                    path = '/' + eventData[0];
                    if (eventCount > 1) {
                        path += '/_bulk';
                    }

                    request = createLogRequest(logger, utils, path, environment, emitter);

                    if (eventCount > 1) {
                        events = [];
                        for (var i = 1; i < eventData.length; i++) {
                          eventData[i]._type = eventData[0];
                          events.push(eventData[i]);
                        }
                        request.write(JSON.stringify(events));
                        request.end();
                    } else {
                        eventData[1]._type = eventData[0];
                        request.end(JSON.stringify([eventData[1]]));
                    }

                } else {

                    // There's more than one type of event.
                    path = '/_bulk';

                    request = createLogRequest(logger, utils, path, environment, emitter);

                    for (var x = 0; x < buffer.length; x++) {
                        eventData = buffer[x];
                        events = [];
                        for (var j = 1; j < eventData.length; j++) {
                            eventData[j]._type = eventData[0];
                            events.push(eventData[j]);

                        }
                        request.write(JSON.stringify(events));
                    }

                    request.end();
                }
            } catch (thrown) {
                emitter.emit('error', 'While reporting events, caught ' + thrown);
            }

            buffer.clear();
        }

        logger.logExit('sendEvents');
    }

    // This is called once we get the list of event types.
    buffer.ready = function ready() {

        logger.logEnter('buffer.ready');

        // setIntervalFunction is passed in as an argument to assist with testing this code path.
        var interval = setIntervalFunction(sendEvents, reportEventDelay);
        interval.unref();

        logger.logExit('buffer.ready');
    };

    // Adds one event to the buffer.
    buffer.addOne = function addOne(eventType, event) {

        logger.logEnter('buffer.addOne ' + eventType);

        if (eventValidator.isValid(eventType, event, emitter)) {
            eventCount++;

            var index = buffer.typeMap[eventType];
            if (index === undefined) {
                buffer.typeMap[eventType] = buffer.length;
                buffer.push([eventType, event]);
            } else {
                buffer[index].push(event);
            }
        } else {
            logger.log(event + ' was rejected for being invalid');
        }

        logger.logExit('buffer.addOne, typeMap is now ' + JSON.stringify(buffer.typeMap));
    };

    // Adds multiple events to the buffer, all of the same type.
    buffer.addMany = function addMany(eventType, events) {

        logger.logEnter('buffer.addMany');

        // if the even type is invalid, skip all
        if (typeof eventValidator.getMappings()[eventType] === 'undefined') {
            emitter.emit('error', eventType + ' is not a known event type.');
            return;
        }

        var index = buffer.typeMap[eventType];
        if (index === undefined) {
            buffer.typeMap[eventType] = buffer.length;
            buffer.push([eventType]); // index is now defined
            index = buffer.typeMap[eventType];
        }

        events.forEach(function(event) {
            if (eventValidator.isValid(eventType, event, emitter)) {
                buffer[index].push(event);
                eventCount += 1;
            }
        });

        logger.logExit('buffer.addMany, typeMap is now ' + JSON.stringify(buffer.typeMap));
    };

    // Removes everything from the buffer.
    buffer.clear = function clear() {

        logger.logEnter('buffer.clear');

        var inBufferBeforeClear = eventCount;

        eventCount = 0;
        buffer.length = 0;
        buffer.typeMap = {};

        logger.logExit('buffer.clear');

        return inBufferBeforeClear;
    };

    logger.logExit('createEventBuffer');

    return buffer;
}

// Creates and initializes a request object for POSTing to Elastic Search.
function createLogRequest(logger, utils, path, environment, emitter) {

    'use strict';

    logger.logEnter('createLogRequest ' + path);
    //var ANALYTICS_VERSION_HEADER = "x-mfp-analytics-version";

    var options = environment.elasticsearchOptions('POST', path);

    var respConsumer = utils.responseConsumer(logger, 'after posting events', 200, emitter, null, 201, options, path);
    var request = environment.request(options, respConsumer);
    request.once('error', function(e) {
        emitter.emit('error', 'Error while reporting events: ' + e);
    });

    request.setHeader('Content-Type', 'application/json');

   // request.setHeader(ANALYTICS_VERSION_HEADER, "2");

    logger.logExit('createLogRequest');

    return request;
}

module.exports = {
    createEventBuffer: _createEventBuffer,
    createLogRequest: createLogRequest
};
