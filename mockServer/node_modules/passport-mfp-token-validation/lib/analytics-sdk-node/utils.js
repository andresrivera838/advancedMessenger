
/**
 * @license
 * Licensed Materials - Property of IBM
 * 5725-I43 (C) Copyright IBM Corp. 2006, 2013. All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */
/*global module, require*/
//Returns a current timestamp unix-style
function _makeUnixCurrentTimestamp() {
    'use strict';
    return (new Date()).getTime();
}

// Builds the value of the 'resources' field for a POST to the UDG.
function _makeUsageData(data) {

    'use strict';

    var resources = [];
    var keys = Object.keys(data);
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key !== 'application_id') {
            resources.push({
                unit: key,
                quantity: data[key]
            });
        }
    }
    return resources;
}

// Returns a function that will consume a response, check for the proper
// status code(s), and report errors.  The success function and the second
// acceptable status code are optional.  If the status code is correct and
// there's a success function, it will be called with the response's body
// passed in.  The failure argument can either be an EventEmitter (to emit an
// error event on) or a callback function.
function _responseConsumer(logger, description, okCode1, failure, success, okCode2) {

    'use strict';

    return function consume(response) {
        response.setEncoding('utf8');
        var body = '';
        response.on('data', function(chunk) {
            body += chunk;
        });
        response.on('end', function() {

            logger.log('response consumer (' + description + ') got code ' + response.statusCode + ' and body:\n' + body);

            // Check for errors.
            if (response.statusCode !== okCode1 && response.statusCode !== okCode2) {
                var message = 'Got statusCode ' + response.statusCode + ' ' + description + '.' + '\n' + body;

                if (typeof failure === 'object' && typeof failure.emit === 'function') {
                    failure.emit('error', message);
                } else {
                    failure();
                }
            } else if (success) {
                success(body);
            }
        });
    };
}

function _getOptionalArguments(args, logger) {

    'use strict';

    var output = {};

    if (args.length > 2) {
        if (typeof args[2] === 'function') {
            output.billingProvider = args[2];
            output.billingProviderIndex = 2;
        } else {
            output.settings = args[2];
            output.billingProvider = args[3];
            output.billingProviderIndex = 3;

            logger.log('A settings object was passed in.');
            logger.log('   localMode ' + output.settings.localMode);
            logger.log('   billingInterval ' + output.settings.billingInterval);
            logger.log('   appCleanupInterval ' + output.settings.appCleanupInterval);
            logger.log('   reportEventInterval ' + output.settings.reportEventInterval);
            logger.log('   billingCallback ' + output.settings.billingCallback);
        }
    }

    var reportEventDelay = 2500;
    if (output.settings && output.settings.reportEventInterval) {
        reportEventDelay = output.settings.reportEventInterval;
    }
    logger.log('Using reportEventDelay ' + reportEventDelay);
    output.reportEventInterval = reportEventDelay;

    // Make an array of arguments for the billingProvider.
    var usageDataArgs = [undefined];
    if (args.length > output.billingProviderIndex) {
        var extras = Array.prototype.slice.call(args, output.billingProviderIndex + 1);
        usageDataArgs = usageDataArgs.concat(extras);

        logger.log('Extra args to billing provider ' + JSON.stringify(extras));
    }
    output.usageDataArgs = usageDataArgs;

    return output;
}

function _validateAnalyticNetworkContextObject(CONSTANT, context) {

    'use strict';

    var msg = '',
        isValid = true;

    if (typeof context !== 'object' || Array.isArray(context)) {
        isValid = false;
        var type = Array.isArray(context) ? "array" : typeof context;
        msg = 'The type of the context object must be object, it was: ' + type;

    } else if (context[CONSTANT.globalTrackingId] &&
        (typeof context[CONSTANT.globalTrackingId] !== 'string' || context[CONSTANT.globalTrackingId].length < 1)) {
        isValid = false;
        msg = 'Missing global tracking id non-zero length string, context.' + [CONSTANT.globalTrackingId] + ' passed was: ' +
            context[CONSTANT.globalTrackingId];

    } else if (typeof context[CONSTANT.inboundRequestURL] !== 'string' || context[CONSTANT.inboundRequestURL].length < 1) {
        isValid = false;
        msg = 'Missing inbound request URL non-zero length string, context.' + CONSTANT.inboundRequestURL + ' passed was: ' +
            context[CONSTANT.inboundRequestURL];

    } else if (typeof context[CONSTANT.outboundRequestURL] !== 'object' &&
        typeof context[CONSTANT.outboundRequestURL] !== 'string') {
        isValid = false;
        msg = 'Missing outbound request URL non-zero length string, context.' + CONSTANT.outboundRequestURL + ' passed was: ' +
            context[CONSTANT.outboundRequestURL];

    } else if (typeof context[CONSTANT.inboundTimestamp] !== 'object' &&
        typeof context[CONSTANT.inboundTimestamp] !== 'number') {
        isValid = false;
        msg = 'Missing inbound timestamp, context.' + CONSTANT.inboundTimestamp + ' passed was: ' +
            context[CONSTANT.inboundTimestamp];

    } else if (typeof context[CONSTANT.outboundBackendTimestamp] !== 'object' &&
        typeof context[CONSTANT.outboundBackendTimestamp] !== 'number') {
        isValid = false;
        msg = 'Missing outbound backend timestamp, context.' + CONSTANT.outboundBackendTimestamp + ' passed was: ' +
            context[CONSTANT.outboundBackendTimestamp];

    } else if (typeof context[CONSTANT.inboundBackendTimestamp] !== 'object' &&
        typeof context[CONSTANT.inboundBackendTimestamp] !== 'number') {
        isValid = false;
        msg = 'Missing inbound backend timestamp, context.' + CONSTANT.inboundBackendTimestamp + ' passed was: ' +
            context[CONSTANT.inboundBackendTimestamp];

    } else if (typeof context[CONSTANT.outboundTimestamp] !== 'object' &&
        typeof context[CONSTANT.outboundTimestamp] !== 'number') {
        isValid = false;
        msg = 'Missing outbound timestamp, context.' + CONSTANT.outboundTimestamp + ' passed was: ' +
            context[CONSTANT.outboundTimestamp];
    }

    return {
        isValid: isValid,
        msg: msg
    };
}

function _throwErrorWhenValidationFails(validator, args, ctx) {
    'use strict';

    var result = validator.apply(ctx, args);
    if (!result.isValid) {
        throw new Error(result.msg);
    }
}

function _getEnvironment(emitterObj, settings, logger, process) {

    'use strict';

    var emitter = emitterObj;

    // See if we're in local mode or not, get an environment object that
    // knows how to operate in this mode, and do mode-specific setup.
    // Environment objects have get and request functions, which map to the
    // similarly-named functions from the http or https module, and functions
    // that return an options object to use when calling get or request.  Those
    // functions are named billingOptions, serviceBrokerOptions, and so on.
    //
    // If there's a problem then this function returns null and an error is
    // emitted.

    var environment = null,
        bodyParser = require('body-parser'),
        url = require('url'),
        fs = require('fs');

    if (settings && settings.localMode) {
        var express = require('express'),
            http = require('http');

        environment = require('./local-mode.js').setupLocalMode(emitter, http, express, bodyParser);

    } else if (!_isBlueMix(process) && _isOnPremise(settings)) {
        /*jshint validthis:true */
        var protocol = require('http');

        if (_isHTTP(settings.onpremise.url)) {
            protocol = require('http');
        } else if (_isHTTPS(settings.onpremise.url)) {
            protocol = require('https');
        }
        environment = require('./onpremise-mode.js').setupOnPremiseMode(emitter, fs, protocol, url, logger, this, JSON.stringify(settings.onpremise));

    } else if (_isBlueMix(process) && !_isOnPremise(settings)) {
        // Performs setup for running in BlueMix, and returns an environment object for
        // tasks specific to BlueMix.  Emits an error and returns null if we can't get
        // the information we need from the VCAP_APPLICATION and VCAP_SERVICES
        // environment variables.
        var https = require('https');

        /*jshint validthis:true */
        environment = require('./bluemix.js').setupBlueMixMode(emitter, logger, this, https, url, process);

    }

    return environment;
}

function _isBlueMix(process) {
    'use strict';

    return (typeof process.env.VCAP_SERVICES !== "undefined" && process.env.VCAP_SERVICES !== 'null' && process.env.VCAP_SERVICES !== null);
}

function _isOnPremise(settings) {
    'use strict';

    return (settings && settings.onpremise);
}

function _isObject(obj) {
    'use strict';
    if (typeof obj === 'undefined' || typeof obj !== 'object' || obj === null || obj === 'null') {
        return false;
    } else {
        return true;
    }
}

function _isHTTP(url) {
    'use strict';
    var CONSTANTS = require('./constants');
    var protocol = url.substring(0, url.indexOf(CONSTANTS.COLON));
    if (protocol === CONSTANTS.HTTP) {
        return true;
    } else {
        return false;
    }
}

function _isHTTPS(url) {
    'use strict';
    var CONSTANTS = require('./constants');
    var protocol = url.substring(0, url.indexOf(CONSTANTS.COLON));
    if (protocol === CONSTANTS.HTTPS) {
        return true;
    } else {
        return false;
    }
}

function _getEmptyAnalyticsEventEmitter() {

    'use strict';

    var EventEmitter = require('events').EventEmitter;

    var emptyEventEmitter = new EventEmitter();

    emptyEventEmitter.logger = {};
    emptyEventEmitter.utils = {};
    emptyEventEmitter.CONSTANT = {};
    emptyEventEmitter.settings = {};
    emptyEventEmitter.billingProvider = {};
    emptyEventEmitter.reportEventDelay = {};
    emptyEventEmitter.usageDataArgs = [];
    emptyEventEmitter.setupEventBuffer = {};
    emptyEventEmitter.reportEvent = function reportEvent() {};
    emptyEventEmitter.reportEvents = function reportEvents() {};
    emptyEventEmitter.runElasticsearchQuery = function runElasticsearchQuery() {};
    emptyEventEmitter.recordInboundNetworkRequest = function recordInboundNetworkRequest() {};
    emptyEventEmitter.recordOutboundNetworkRequest = function recordOutboundNetworkRequest() {};
    emptyEventEmitter.recordInboundNetworkResponse = function recordInboundNetworkResponse() {};
    emptyEventEmitter.recordOutboundNetworkResponse = function recordOutboundNetworkResponse() {};
    emptyEventEmitter.reportNetworkEvent = function reportNetworkEvent() {};

    return emptyEventEmitter;
}

module.exports = {
    makeUnixCurrentTimestamp: _makeUnixCurrentTimestamp,
    makeUsageData: _makeUsageData,
    responseConsumer: _responseConsumer,
    getOptionalArguments: _getOptionalArguments,
    validateAnalyticNetworkContextObject: _validateAnalyticNetworkContextObject,
    throwErrorWhenValidationFails: _throwErrorWhenValidationFails,
    getEnvironment: _getEnvironment,
    getEmptyAnalyticsEventEmitter: _getEmptyAnalyticsEventEmitter,
    isObject: _isObject,
    isHTTP: _isHTTP,
    isHTTPS: _isHTTPS,
    isBlueMix: _isBlueMix,
    isOnPremise: _isOnPremise
};