
/**
 * @license
 * Licensed Materials - Property of IBM
 * 5725-I43 (C) Copyright IBM Corp. 2006, 2013. All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */
/*global module*/
// This is a map from application IDs to the space and organization IDs
// of the app, plus the timestamp of when it was last accessed.  Values
// take this form: {spaceID: 'x', orgID: 'y', lastAccess: 000000000}.
var appData = {};

// Starts a timer to periodically call the optional billing provider passed into the Analytics SDK when initialized.
function _setupCallsToBillingProvider(environment, settings, logger, usageDataArgs, billingProvider, utils, serviceName, emitter) {

    'use strict';

    var startTime = Date.now(),
        lastTimeReported,
        delay = environment.billingInterval;

    if (settings && settings.billingInterval) {
        delay = settings.billingInterval;
    }

    logger.log('Setting up calls to billingProvider, delay ' + delay);

    // Wake up periodically (10 minutes, configuration) to do billing.
    var interval = setInterval(function pollForUsageData() {

        logger.logEnter('pollForUsageData, lastTimeReported ' + lastTimeReported);

        try {
            // Extract the usage data from the billing provider.
            usageDataArgs[0] = lastTimeReported;
            var usageData = billingProvider.apply(this, usageDataArgs);

            logger.log('billingProvider returned:\n' + JSON.stringify(usageData));

            if (lastTimeReported) {
                startTime = lastTimeReported;
            }

            var now = Date.now();
            if (usageData && usageData.length > 0) {

                var completeCallback = function(location) {
                    if (now > lastTimeReported) {
                        lastTimeReported = now;
                    }

                    if (settings && settings.billingCallback) {
                        settings.billingCallback(location);
                    }
                };

                processUsageData(serviceName, usageData, startTime, now, completeCallback, logger, appData, emitter, environment, utils);
            }
        } catch (e) {
            emitter.emit('error', 'Error while reporting usage data: ' + e);
        }

        logger.logExit('pollForUsageData');

    }, delay);

    interval.unref();

    // Set up the callback that purges old data from the cache.
    var cleanupDelay = 1000 * 60 * 60 * 24; // milliseconds in one day
    if (settings && settings.appCleanupInterval) {
        cleanupDelay = settings.appCleanupInterval;
    }

    logger.log('appCleanupInterval ' + cleanupDelay);

    var threshold = cleanupDelay * 7;
    interval = setInterval(function cleanup() {

        logger.logEnter('cleanup');

        var now = Date.now();
        for (var n in appData) {
            if (now - appData[n].lastAccess > threshold) {
                logger.log('deleting cached app data for ' + n);
                delete appData[n];
            }
        }

        logger.logExit('cleanup');

    }, cleanupDelay);

    interval.unref();
}

// The ID of the service.
var serviceID;

// POSTs to the usage data gateway.  The usageData array should have at
// least one element.  complete is a callback that's invoked after we
// successfully POST the data.
function processUsageData(serviceName, usageData, startTime, endTime, complete, logger, appData, emitter, environment, utils) {

    'use strict';

    logger.logEnter('processUsageData');

    // This is what we send to the UDG.
    var payload = {
        service_instances: []
    };

    // How many elements of usageData haven't been processed yet.
    var elementsToProcess = usageData.length;

    // Iterate the usage data array, one element per app id.
    for (var i = 0; i < usageData.length; i++) {
        var appUsageData = usageData[i],
            appID = appUsageData.application_id,
            identifiers = appData[appID];

        // Do we have information cached in our appData array about this app id?
        if (identifiers) {
            // Found data in our cache.  Move forward.
            processAppUsageData(appID, identifiers, appUsageData);
        } else {
            // No data found in the cache.  Time to populate it.
            getAppData(appID, appUsageData);
        }
    }

    // Adds a single app's usage data to the payload, then calls
    // elementProcessed.
    function processAppUsageData(appID, identifiers, appUsageData) {

        logger.logEnter('processAppUsageData for ' + appID);

        identifiers.lastAccess = Date.now();

        payload.service_instances.push({
            service_instance_id: identifiers.instanceID,
            usage: [{
                start: startTime,
                end: endTime,
                organization_guid: identifiers.orgID,
                space_guid: identifiers.spaceID,
                consumer: {
                    type: 'cloud_foundry_application',
                    value: appID
                },
                resources: utils.makeUsageData(appUsageData)
            }]
        });

        elementProcessed();

        logger.logExit('processAppUsageData');
    }

    // This is used when we have an unfamiliar appID.  We get its org,
    // space and instance IDs from the service broker, then we call
    // processAppUsageData.  If there's an error that prevents us from
    // calling processAppUsageData, elementProcessed is called.
    function getAppData(appID, appUsageData) {

        logger.logEnter('getAppData for ' + appID);

        var resultFromServiceBrokerCallback = function(json) {

            logger.log('Result from service broker is ' + json);
            var reply;

            try {
                reply = JSON.parse(json);
            } catch (e) {
                emitter.emit('error', 'Error parsing service broker reponse JSON: ' + e);
                elementProcessed();
                return;
            }

            // We don't report an error if the service broker had no
            // info about the appID.  The Data service (maybe others
            // too) will give us IDs of apps that have been deleted
            // or unbound from Data.
            var found = false;
            if (Array.isArray(reply)) {
                for (var i = 0; i < reply.length; i++) {
                    var serviceInfo = reply[i];
                    // Find a match for the name of the service as the broker returns
                    // data for all mbaas services related to the app id.
                    if (serviceInfo.service_name === serviceName) {
                        found = true;
                        if (!serviceID) {
                            // Save this once because it never changes.
                            serviceID = serviceInfo.service_id;
                        }
                        // Build the object of per app id information.
                        var identifiers = {
                            spaceID: serviceInfo.space_guid,
                            orgID: serviceInfo.organization_guid,
                            instanceID: serviceInfo.instance_id
                        };
                        // Save ths information in our cache (appData array) and process it.
                        appData[appID] = identifiers;
                        processAppUsageData(appID, identifiers, appUsageData);
                        break;
                    }
                }
            }

            if (!found) {
                elementProcessed();
            }
        };

        var respConsumerCallback = utils.responseConsumer(logger, 'calling service broker',
            200, elementProcessed, resultFromServiceBrokerCallback);

        var req = environment.get(environment.serviceBrokerOptions('GET', '/v2/apps/' + appID), respConsumerCallback);

        req.on('error', function(e) {
            emitter.emit('error', 'Error calling service broker: ' + e);
            elementProcessed();
        });

        logger.logExit('getAppData for ' + appID);
    }

    // This is called after each element of the usageData array has been
    // processed, even if we called the service broker and there was an
    // error.  If all elements have been processed, it posts to the UDG.
    function elementProcessed() {

        logger.logEnter('elementProcessed, element ' + elementsToProcess);

        elementsToProcess--;

        if (elementsToProcess === 0) {
            // Now we can POST the data.

            logger.log('Posting usage data:\n' + JSON.stringify(payload));

            if (payload.service_instances.length > 0) {
                var options = environment.billingOptions('POST', '/v1/metering/services/' + serviceID + '/usage'),
                    request = environment.request(options, utils.responseConsumer(logger, 'after posting usage data', 201, emitter));

                request.once('error', function(e) {
                    emitter.emit('error', 'Error while posting usage data: ' + e);
                });

                request.setHeader('Content-Type', 'application/json');
                request.end(JSON.stringify(payload));

                request.on('response', function(response) {
                    // The response data must be consumed even though we don't care about it.
                    response.on('data', function() {});

                    logger.log('The response code from posting usage data was ' + response.statusCode +
                        ', with Location header: ' + response.headers.location);

                    // Invoke the callback if we were successful.
                    if (response.statusCode === 201) {
                        complete(response.headers.location);
                    }
                });

            } else {

                logger.log("There's no usage data to POST, skipping the call to UDG.");
            }
        }

        logger.logExit('elementProcessed');
    }

    logger.logExit('processUsageData');
}

module.exports = {
    setupCallsToBillingProvider: _setupCallsToBillingProvider
};