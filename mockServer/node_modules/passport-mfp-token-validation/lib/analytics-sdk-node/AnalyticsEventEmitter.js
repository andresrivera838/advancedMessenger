
/**
 * @license
 * Licensed Materials - Property of IBM
 * 5725-I43 (C) Copyright IBM Corp. 2006, 2013. All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */
/*global module, require, process*/
var EventEmitter = require('events').EventEmitter;
var util = require('util');

// This is the main class that gets returned by our SDK init method.  It contains several public functions intended to be
// consumed by users of the SDK.  Similar to AnalyticsSDK.java for our java SDK.  See README.md for detailed documentation.
function AnalyticsEventEmitter(logger, utils, CONSTANT, onErrorCallback, optionalArguments) {
    'use strict';

    EventEmitter.call(this);

    this.logger = logger || {};
    this.utils = utils || {};
    this.CONSTANT = CONSTANT || {};

    optionalArguments = optionalArguments || {};

    this.settings = optionalArguments.settings;
    this.billingProvider = optionalArguments.billingProvider;
    this.reportEventDelay = optionalArguments.reportEventInterval;
    this.usageDataArgs = optionalArguments.usageDataArgs;

    // Register onErrorCallback callback
    this.on('error', onErrorCallback || function(err) {
        this.logger.log('Emitted an error event: ' + err);
    });
}

util.inherits(AnalyticsEventEmitter, EventEmitter);

AnalyticsEventEmitter.prototype.setupEventBuffer = function setupEventBuffer(eventBufferFactory, serviceName, dataUsageProcessor, setIntervalFunction) {

    'use strict';

    var that = this;

    var EventReportValidator = that.environment.loadValidator();

    // Returns an event buffer, which stores events and periodically sends them
    // to Elastic Search.  Use eventBuffer.addOne() or addMany() to put events in the buffer.
    var eventBuffer = eventBufferFactory.createEventBuffer(that.logger, that.utils,
        that.reportEventDelay, that, that.environment, EventReportValidator, setIntervalFunction);

    that.eventBuffer = eventBuffer;

    // Now the event buffer can begin processing events.
    eventBuffer.ready();

    // Set up calls to billingProvider.
    if (that.billingProvider) {
        dataUsageProcessor.setupCallsToBillingProvider(that.environment, that.settings,
            that.logger, that.usageDataArgs, that.billingProvider, that.utils, serviceName, that);
    }
};

// PUBLIC FUNCTION reportEvent
AnalyticsEventEmitter.prototype.reportEvent = function reportEvent(eventType, eventObj) {

    'use strict';

    var that = this;

    that.logger.logEnter('reportEvent ' + eventType + ' ' + JSON.stringify(eventObj));

    try {
        eventObj.timestamp = that.utils.makeUnixCurrentTimestamp();
        that.eventBuffer.addOne(eventType, eventObj);
    } catch (thrown) {
        that.emit('error', 'While reporting an event, caught ' + thrown);
    }

    that.logger.logExit('reportEvent');
};

// PUBLIC FUNCTION reportEvents
AnalyticsEventEmitter.prototype.reportEvents = function reportEvents() {

    'use strict';

    var that = this;

    that.logger.logEnter('reportEvents');

    try {
        var timestamp = that.utils.makeUnixCurrentTimestamp();

        for (var i = 0; i < arguments.length; i += 2) {
            var eventType = arguments[i],
                events = arguments[i + 1];

            that.logger.log('  reportEvents has ' + eventType + ':\n  ' + JSON.stringify(events));

            for (var j = 0; j < events.length; j++) {
                events[j].timestamp = timestamp;
            }

            that.eventBuffer.addMany(eventType, events);
        }
    } catch (thrown) {
        that.emit('error', 'While reporting events, caught ' + thrown);
    }

    that.logger.logExit('reportEvents');
};

// PUBLIC FUNCTION runElasticsearchQuery
AnalyticsEventEmitter.prototype.runElasticsearchQuery = function runElasticsearchQuery(queryBody, eventTypes, callback) {

    'use strict';

    var that = this;

    that.logger.logEnter('runElasticsearchQuery');

    try {

        var searchTypeValue = arguments[3];

        that.logger.log('  queryBody: ' + JSON.stringify(queryBody) + ' eventTypes: ' +
            eventTypes + ' searchType: ' + searchTypeValue);

        // POST the query, pass the result to the callback, report errors.
        var path = '/' + eventTypes + '/_search';

        if (searchTypeValue) {
            // type of elasticsearch query (e.g. count only).
            path += '?search_type=' + searchTypeValue;
        }

        var options = that.environment.elasticsearchOptions('POST', path);

        var responseConsumerCallback = function(json) {

            that.logger.log('result from query is ' + json);

            try {
                var reply = JSON.parse(json);
                callback(reply);
            } catch (e) {
                that.emit('error', 'Error parsing query result JSON: ' + e);
            }
        };

        var requestCallback = that.utils.responseConsumer(that.logger,
            'after posting elasticsearch query', 200, this, responseConsumerCallback);

        var request = that.environment.request(options, requestCallback);

        request.once('error', function(e) {
            that.emit('error', 'Error while posting query: ' + JSON.stringify(queryBody) + ': ' + e);
        });

        request.setHeader('Content-Type', 'application/json');
        request.end(JSON.stringify(queryBody));

    } catch (thrown) {
        that.emit('error', 'In runElasticsearchQuery, caught ' + thrown);
    }

    that.logger.logExit('runElasticsearchQuery');
};

// PUBLIC FUNCTION recordInboundNetworkRequest
AnalyticsEventEmitter.prototype.recordInboundNetworkRequest = function recordInboundNetworkRequest(context) {

    'use strict';

    var that = this;

    that.logger.logEnter('recordInboundNetworkRequest, context = ' + JSON.stringify(context));

    context = context || {};

    context[that.CONSTANT.outboundRequestURL] = null;

    context[that.CONSTANT.inboundTimestamp] = that.utils.makeUnixCurrentTimestamp();
    context[that.CONSTANT.outboundBackendTimestamp] = null;
    context[that.CONSTANT.inboundBackendTimestamp] = null;
    context[that.CONSTANT.outboundTimestamp] = null;

    that.utils.throwErrorWhenValidationFails(that.utils.validateAnalyticNetworkContextObject, [that.CONSTANT, context], that);

    that.logger.logExit('recordInboundNetworkRequest');
};

// PUBLIC FUNCTION recordOutboundNetworkRequest
AnalyticsEventEmitter.prototype.recordOutboundNetworkRequest = function recordOutboundNetworkRequest(context, url) {

    'use strict';

    var that = this;

    that.logger.logEnter('recordOutboundNetworkRequest, context = ' + JSON.stringify(context) + ', url = ' + url);

    that.utils.throwErrorWhenValidationFails(that.utils.validateAnalyticNetworkContextObject, [that.CONSTANT, context], that);

    if (typeof url !== 'string' || url.length < 1) {
        throw new Error('Missing outbound request URL non-zero string, url passed was: ' + url);
    }

    context[that.CONSTANT.outboundRequestURL] = url;

    context[that.CONSTANT.outboundBackendTimestamp] = that.utils.makeUnixCurrentTimestamp();

    that.logger.logExit('recordOutboundNetworkRequest');
};

// PUBLIC FUNCTION recordInboundNetworkResponse
AnalyticsEventEmitter.prototype.recordInboundNetworkResponse = function recordInboundNetworkResponse(context) {

    'use strict';

    var that = this;

    that.logger.logEnter('recordInboundNetworkResponse, context = ' + JSON.stringify(context));

    that.utils.throwErrorWhenValidationFails(that.utils.validateAnalyticNetworkContextObject, [that.CONSTANT, context], that);

    context[that.CONSTANT.inboundBackendTimestamp] = that.utils.makeUnixCurrentTimestamp();

    that.logger.logExit('recordInboundNetworkResponse');
};

// PUBLIC FUNCTION recordOutboundNetworkResponse
AnalyticsEventEmitter.prototype.recordOutboundNetworkResponse = function recordOutboundNetworkResponse(context) {

    'use strict';

    var that = this;

    that.logger.logEnter('recordOutboundNetworkResponse, context = ' + JSON.stringify(context));

    that.utils.throwErrorWhenValidationFails(that.utils.validateAnalyticNetworkContextObject, [that.CONSTANT, context], that);

    context[that.CONSTANT.outboundTimestamp] = that.utils.makeUnixCurrentTimestamp();

    that.logger.logExit('recordOutboundNetworkResponse');
};

// PUBLIC FUNCTION reportNetworkEvent
AnalyticsEventEmitter.prototype.reportNetworkEvent = function reportNetworkEvent(context) {

    'use strict';

    var that = this;

    that.logger.logEnter('reportNetworkEvent, context = ' + JSON.stringify(context));

    that.utils.throwErrorWhenValidationFails(that.utils.validateAnalyticNetworkContextObject, [that.CONSTANT, context], that);

    var eventObj = {};

    eventObj[that.CONSTANT.globalTrackingId] = context[that.CONSTANT.globalTrackingId];
    eventObj[that.CONSTANT.inboundRequestURL] = context[that.CONSTANT.inboundRequestURL];
    eventObj[that.CONSTANT.inboundTimestamp] = context[that.CONSTANT.inboundTimestamp];
    eventObj[that.CONSTANT.outboundTimestamp] = context[that.CONSTANT.outboundTimestamp];

    if (typeof context[that.CONSTANT.outboundRequestURL] === 'string' &&
        context[that.CONSTANT.outboundRequestURL].length > 0) {
        eventObj[that.CONSTANT.outboundRequestURL] = context[that.CONSTANT.outboundRequestURL];
    }

    if (typeof context[that.CONSTANT.outboundBackendTimestamp] === 'number' &&
        context[that.CONSTANT.outboundBackendTimestamp].toString().length === 13) {
        eventObj[that.CONSTANT.requestProcessingTime] = context[that.CONSTANT.outboundBackendTimestamp] -
            context[that.CONSTANT.inboundTimestamp];
    }

    if (typeof context[that.CONSTANT.inboundBackendTimestamp] === 'number' &&
        context[that.CONSTANT.inboundBackendTimestamp].toString().length === 13) {
        eventObj[that.CONSTANT.responseProcessingTime] = context[that.CONSTANT.outboundTimestamp] -
            context[that.CONSTANT.inboundBackendTimestamp];
    }

    eventObj[that.CONSTANT.duration] = context[that.CONSTANT.outboundTimestamp] - context[that.CONSTANT.inboundTimestamp];

    process.nextTick(function() {
        that.reportEvent(that.CONSTANT.MobileServerNetworkTransactions, eventObj);
    });

    that.logger.logExit('reportNetworkEvent');
};

module.exports = AnalyticsEventEmitter;