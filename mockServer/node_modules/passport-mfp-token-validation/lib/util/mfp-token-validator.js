/**
 *  Copyright 2016 IBM Corp. All Rights Reserved
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */



var request = require('request'),
util = require('util'),
Promise = require('bluebird'),
RejectionMessage = require('./responses').RejectionMessage,
loggerWrapper = require('./security-logger'),
FilterUtil = require('./filter-util'),
Constant = require("../constant"),
_ = require('underscore'),
Buffer = require('buffer'),
Url = require('url');

var tokenValidator = {}; 

tokenValidator.validate = function(options,done) {
    var strategy = this;
    var validator = new ValidatorExecuter(strategy,options,done);
    
    if ( (options.authorization !== undefined) && (options.authorization.startsWith(Constant.AUTHORIZATION_BEARER)) ) {
        
        // The Authorization's value is:"Bearer" 1*SP b64token
        options.token = options.authorization.substr(Constant.AUTHORIZATION_BEARER.length).trim();
        validateToken();
    } else {
        var validationCode;
        if (options.authorization === undefined) {
            loggerWrapper.getLogger().debug('The client sent a request without an Authorization header.');
            validationCode = 'AUTHORIZATION_FAILED_MISSING_AUTH_HEADER';
        } else {
            loggerWrapper.getLogger().debug('The token does not start with Bearer');
            validationCode = 'AUTHORIZATION_FAILED_MISSING_TOKEN';
        }
        done(null,null,{code:Constant.AUTHORIZATION_FAILED_MISSING_AUTHORIZATION, status:401, validationCode:validationCode});
    }
    
    function validateToken() {
        return validator.obtainConfClientToken().then(function(confClientToken) {
            return validator.introspect(confClientToken, options.token).then(function(body) {  
                validator.validateIntrospectionData(body);
            }).catch(function(error) {
                if (error.reason == Constant.UNAUTHORIZED_TO_INTROSPECT) {
                    if (++validator.attempts < validator.maxAttemps) {
                        return validateToken();
                    } else {
                        done(null, null, error);
                    }
                } else {
                    done(null, null, error);
                }
            });
        }).catch(function(error) {
            done(null, null, error);
        });
    }
}

function ValidatorExecuter(strategy,options,done) {
    
    this.authServerUrl;
    this.userid;
    this.pass;
    this.maxAttemps = 4;
    this.attempts = 0;
    
    if (util.isObject(options)) {
        if (util.isString(options.authServerUrl)) 
            this.authServerUrl = options.authServerUrl;
        if (util.isString(options.confClientID)) 
            this.userid = options.confClientID;
        if (util.isString(options.confClientPass)) 
            this.pass = options.confClientPass;
    }
    if (!this.authServerUrl.endsWith('/')) {
        // Support both cases for the user's insertion. For example:
        // http://localhost:9080/mfp/api  or  http://localhost:9080/mfp/api/
        this.authServerUrl = this.authServerUrl + '/';
    }
    
    function makePostRequest(url, form, authHeader, certificate) {
        var requestData = {
            url: url,
            method: "POST",
            form: form,
            json: true
        };
        if (authHeader !== undefined) {
            requestData.headers = {};
            requestData.headers.Authorization = authHeader;
        }
        if (certificate !== undefined) {
            requestData.ca = certificate
        }
        return requestData;
    }
    
    function doConnectionError(reject, error, url, validationCode) {
        if (error.code == 'ECONNREFUSED') {
            reject(RejectionMessage(Constant.CONNECTION_REFUSED + url, error, Constant.AUTHORIZATION_FAILED_INTERNAL_SERVER_ERROR, 500, validationCode));
        } else if (error.code == 'ETIMEDOUT') {
            reject(RejectionMessage(Constant.CONNECTION_TIMED_OUT + url, error, Constant.AUTHORIZATION_FAILED_INTERNAL_SERVER_ERROR, 500, validationCode));
        } else if (error.code == 'DEPTH_ZERO_SELF_SIGNED_CERT') {
            reject(RejectionMessage(Constant.CONNECTION_CERT + url, error, Constant.AUTHORIZATION_FAILED_INTERNAL_SERVER_ERROR, 500, validationCode));
        } else {
            reject(RejectionMessage(Constant.CONNECTION_ERROR + url, error, Constant.AUTHORIZATION_FAILED_INTERNAL_SERVER_ERROR, 500, validationCode));
        }        
    }
    
    // Obtains a token for the node filter itself (by mfp).
    this.obtainConfClientToken = function() {
        var tokenUrl = Url.resolve(this.authServerUrl, Constant.TOKEN_URL_SUFFIX);
        
        if ( (this.userid !== undefined) && (this.pass !== undefined) ) {
            var auth = "Basic " + new Buffer.Buffer(this.userid + Constant.COLON + this.pass).toString("base64");            
        } else {
            var msg = 'No confClientID or confClientPass, if you are working in embedded-AZ mode, token validation will fail.';
            loggerWrapper.getLogger().debug(msg);            
        }
        var askedForScope = "authorization.introspect";
        
        return new Promise(function (fulfill, reject){
            var token = strategy.confClientTokenCache.get(tokenUrl);
            
            if (_.isNull(token) || _.isUndefined(token) || _.isEmpty(token)) {
                var form = {
                    grant_type: "client_credentials",
                    "scope": askedForScope        
                };
                var requestData = makePostRequest(tokenUrl, form, auth, strategy.certificate);
                
                request(requestData, function(error, response, body) {
                    if (error) {
                        doConnectionError(reject, error, tokenUrl, 'TOKEN_FAILED_INTERNAL_SERVER_ERROR');
                    } else if (200 == response.statusCode) {
                        
                        if (body.expires_in) {
                            
                            // Confidence for the possibility that the confidential client token
                            // would be invalid in introspection phase.
                            if (body.expires_in > 30) {
                                body.expires_in = body.expires_in - 30;
                            }
                            
                            strategy.confClientTokenCache.set(tokenUrl, body.access_token, body.expires_in == 0 ? 1:body.expires_in);
                            loggerWrapper.getLogger().debug('Received confidential client token by ' + tokenUrl);
                            
                            // Date.now is since Epoch.
                            // body.expires_in is measured in seconds.
                            var tokenCachedUntil = Date.now() + 1000 * body.expires_in;
                            loggerWrapper.getLogger().debug('Confidential client token will be cached until ' + new Date(tokenCachedUntil));                            
                        }

                        fulfill(body.access_token);
                        
                    } else if (400 == response.statusCode) {
                        // Sending 500 to application because it should not expose servers issues.
                        
                        if (response.body.error == Constant.AUTHORIZATION_FAILED_INVALID_CLIENT) {
                            // The filter is not defined as a confidential client in MFP.
                            reject(RejectionMessage(Constant.CONF_CLIENT_NOT_DEFINED, null, Constant.AUTHORIZATION_FAILED_INTERNAL_SERVER_ERROR, 500, 'TOKEN_FAILED_UNKNOWN_CLIENT'));
                        } else if (response.body.error == Constant.AUTHORIZATION_FAILED_INVALID_SCOPE) {
                            // The defined confidential client's scope in MFP server is invalid i.e. askedForScope's value is not contained in the allowed scope.
                            reject(RejectionMessage(Constant.CONF_CLIENT_INVALID_SCOPE, null, Constant.AUTHORIZATION_FAILED_INTERNAL_SERVER_ERROR, 500, 'TOKEN_FAILED_INVALID_GRANT'));
                        } else {
                            // Other reasons, related to bad request.
                            reject(RejectionMessage(Constant.BAD_REQUEST, null, Constant.AUTHORIZATION_FAILED_INTERNAL_SERVER_ERROR, 500, 'TOKEN_FAILED_INTERNAL_SERVER_ERROR'));
                        }
                        
                    } else {
                        // Other reasons.
                        reject(RejectionMessage(Constant.FAILED_TO_OBTAIN_CONF_CLIENT_TOKEN, null, Constant.AUTHORIZATION_FAILED_INTERNAL_SERVER_ERROR, 500, 'TOKEN_FAILED_INTERNAL_SERVER_ERROR'));
                    }
                });
                
            } else {
                loggerWrapper.getLogger().debug('Using confidential client token by the cache.');
                fulfill(token);
            }
        }); 
    }
    
    this.introspect = function (confClientToken, appToken) {
        // confClientToken is the access token that was received by obtainConfClientToken.
        // appToken is the application token - the token of the mobile application, should be in the request's body.
        
        if (!_.isNull(confClientToken) && !_.isUndefined(confClientToken) && !_.isEmpty(confClientToken)) {
            var auth = Constant.AUTHORIZATION_BEARER + ' ' + confClientToken;
        }
        var autoServerUrl = this.authServerUrl;
        var introspectionUrl = Url.resolve(autoServerUrl, Constant.INTROSPECTION_URL_SUFFIX);
                
        return new Promise(function (fulfill, reject){
            var securityContext = strategy.securityContextCache.get(options.token);
            
            if (_.isNull(securityContext) || _.isUndefined(securityContext) || _.isEmpty(securityContext)) {
                var form = {
                    "token": appToken,
                    "token_type_hint": "access_token"
                };
                var requestData = makePostRequest(introspectionUrl, form, auth, strategy.certificate);
                
                request(requestData, function(error, response, body){
                    if (error) {
                        doConnectionError(reject, error, introspectionUrl, 'AUTHORIZATION_FAILED_INTERNAL_SERVER_ERROR');
                    } else {
                        if (200 == response.statusCode) {
                            loggerWrapper.getLogger().debug('Received 200 OK for introspection by ' + introspectionUrl);
                            fulfill(body); // The body contains the security context.
                        } else if ( (401 == response.statusCode) || (403 == response.statusCode) ) {
                            // Unauthorized to introspect, perhaps the confidential client token has become invalid - get a new one.
                            
                            // Removes the cached confidential client token.
                            var tokenUrl = Url.resolve(autoServerUrl, Constant.TOKEN_URL_SUFFIX);
                            strategy.confClientTokenCache.del(tokenUrl);
                            
                            reject(RejectionMessage(Constant.UNAUTHORIZED_TO_INTROSPECT,Constant.UNAUTHORIZED_TO_INTROSPECT_REASON, 
                                Constant.AUTHORIZATION_FAILED_INTERNAL_SERVER_ERROR, 500, 'AUTHORIZATION_FAILED_INVALID_CREDENTIALS'));
                            
                        } else if (409 == response.statusCode) {
                            // The application resent the original request.
                            reject(RejectionMessage(Constant.AUTHORIZATION_FAILED_MFP_SERVER_CONFLICT_RESPONSE_REASON, null, 
                                Constant.AUTHORIZATION_FAILED_MFP_SERVER_CONFLICT_RESPONSE, response.statusCode,'AUTHORIZATION_PENDING'));
                        } else {
                            reject(RejectionMessage(Constant.BAD_REQUEST, null, Constant.AUTHORIZATION_FAILED_INTERNAL_SERVER_ERROR, 500,'AUTHORIZATION_FAILED_INTERNAL_SERVER_ERROR'));
                        }
                    }
                });
                
            } else {
                loggerWrapper.getLogger().debug('Using security context by the cache.');
                fulfill(securityContext);
            }
        });
    }
    
    this.validateIntrospectionData = function(data) {
        if (_.isNull(data) || _.isUndefined(data) || _.isEmpty(data)){
            // We have no introspection data from validationManager, should
            // not happen if we didn't have an error.
            loggerWrapper.getLogger().warn('The introspection data does not exist, sends 400 to client');
            return done(null,null,{code:Constant.AUTHORIZATION_FAILED_INVALID_REQUEST, status:400, validationCode:'AUTHORIZATION_FAILED'});
        }
        if (data[Constant.ACTIVE] == false) {
            loggerWrapper.getLogger().warn('The client token is invalid, sends 401 to client');
            return done(null,null,{code:Constant.AUTHORIZATION_FAILED_INVALID_TOKEN, status:401, validationCode:'AUTHORIZATION_FAILED_INVALID_ACCESS_TOKEN'});
        }
        
        if (!validateScope(data[Constant.SCOPE], options.scope)) {
            // The status must be 401 and not 403, because passport module will add WWW-Authenticate header only if the status is 401.
            // mfp-passport.js considerates the code in order to decide the response's http status code.
            loggerWrapper.getLogger().warn('The required scope(s) are not contained in the granted scope(s), sends 403 to client');
            return done(null,null,{code:Constant.AUTHORIZATION_FAILED_INSUFFICIENT_SCOPE, status:401, validationCode:'AUTHORIZATION_FAILED_INSUFFICIENT_SCOPE', scope:options.scope});
        }
        loggerWrapper.getLogger().debug('The required scope(s) are contained in the granted scope(s), authorization succeeds');
        var securityContextKey = options.token;
        var securityContext = data;
        
        // Both data.exp and Date.now are since Epoch.
        var ttl = Math.floor((data.exp - Date.now()) / 1000);
        
        // ttl - Avoid infinite ttl which could be a result of the mathematical operations (floor).
        strategy.securityContextCache.set(securityContextKey,securityContext, ttl == 0 ? 1:ttl);
        return done(null,securityContext,null);
    }
    
    function validateScope(grantedScope, requiredScope) {
        var grantedScopesArray = FilterUtil.getArrayFromString(grantedScope, ' ');
        var requiredScopeArray = FilterUtil.getArrayFromString(requiredScope, ' ');
        var result = _.difference(requiredScopeArray, _.intersection(requiredScopeArray, grantedScopesArray));
        if (result.length == 0) {
            return true;
        }
        return false;
    }
}

exports = module.exports = tokenValidator;